<?xml version="1.0" encoding="utf-8"?>
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildProjectDirectory)\Properties\template-builder.props" 
          Condition="Exists('$(MSBuildProjectDirectory)\Properties\template-builder.props')" />
  <!--
  1. Discover all .vstemplate files
  2. For each .vstemplate file, go up one folder and create a .zip from the content (exluding the Definitions folder)
  -->

  <PropertyGroup>
    <!-- 
    Constants 
    -->
    <ls-BuildRoot Condition=" '$(ls-BuildRoot)'=='' ">$(MSBuildProjectDirectory)\Build\</ls-BuildRoot>
    <ls-BuildLib Condition=" '$(ls-BuildLib)'=='' and Exists('$(MSBuildThisFileDirectory)\ligershark.templates.targets')">$(MSBuildThisFileDirectory)\</ls-BuildLib>
    <ls-BuildLib Condition=" '$(ls-BuildLib)'=='' ">$(ls-BuildRoot)Lib\</ls-BuildLib>
    
    <!-- 
    Item Templates 
    -->
    <ls-ItemTemplateRoot Condition=" '$(ls-ItemTemplateRoot)'=='' ">$(MSBuildProjectDirectory)\ItemTemplates\</ls-ItemTemplateRoot>
    <ls-ItemTemplateOutputRoot Condition=" '$(ls-ItemTemplateOutputRoot)'=='' ">$(IntermediateOutputPath)ls-ItemTemplates\</ls-ItemTemplateOutputRoot>
    
    <ls-ItemTemplatesExtendBuild Condition=" '$(ls-ItemTemplatesExtendBuild)'=='' ">true</ls-ItemTemplatesExtendBuild>
    <!-- This is where all the Item Template .zip files will be located -->
    <ls-ItemTemplateZipRootFolder Condition=" '$(ls-ItemTemplateZipRootFolder)'=='' ">Output\ItemTemplates\</ls-ItemTemplateZipRootFolder>
    
    <!--
    Project Templates
    -->
    <ls-ProjectTemplateRoot Condition=" '$(ls-ProjectTemplateRoot)'=='' ">$(MSBuildProjectDirectory)\ProjectTemplates\</ls-ProjectTemplateRoot>
    <ls-ProjectTemplateOutputRoot Condition=" '$(ls-ProjectTemplateOutputRoot)'=='' ">$(IntermediateOutputPath)ls-ProjectTemplates\</ls-ProjectTemplateOutputRoot>
    <!-- This is where all the Project Template .zip files will be located -->
    <ls-ProjectTemplateZipRootFolder Condition=" '$(ls-ProjectTemplateZipRootFolder)'=='' ">Output\ProjectTemplates\</ls-ProjectTemplateZipRootFolder>
           
    <!-- This is normally defined by the .props file imported above ( $(MSBuildProjectDirectory)\Properties\template-builder.props )-->
    <ls-TemplateSubFolder Condition=" '$(ls-TemplateSubFolder)'=='' ">Custom Templates</ls-TemplateSubFolder>
    
    <ls-MSBuildLibPathLocal Condition=" '$(ls-MSBuildLibPathLocal)'=='' ">$(LocalAppData)\Microsoft\MSBuild\TemplateBuilder\v1.0.0.0\</ls-MSBuildLibPathLocal>
    <ls-MSBuildLibPath Condition=" '$(ls-MSBuildLibPath)'=='' ">$(MSBuildThisFileDirectory)</ls-MSBuildLibPath>
  </PropertyGroup>

  <PropertyGroup>
    <ls-UseHardLinksForItemTemplatesCopy Condition=" '$(ls-UseHardLinksForItemTemplatesCopy)'=='' ">false</ls-UseHardLinksForItemTemplatesCopy>
  </PropertyGroup>

  <ItemGroup>
    <ls-BuildAssemblies Include="$(ls-MSBuildLibPath)*.dll"/>
  </ItemGroup>
  <Target Name="CopyMSBuildFilesToLocalAppData"
          Inputs="@(ls-BuildAssemblies)"
          Outputs="@(ls-BuildAssemblies->'$(ls-MSBuildLibPathLocal)%(FileName)%(Extension)')">
    
    <MakeDir Directories="$(ls-MSBuildLibPathLocal)"/>
    <Copy SourceFiles="@(ls-BuildAssemblies)"
          DestinationFiles="@(ls-BuildAssemblies->'$(ls-MSBuildLibPathLocal)%(FileName)%(Extension)')"
          Condition="!Exists('$(ls-MSBuildLibPathLocal)%(ls-BuildAssemblies.FileName)%(ls-BuildAssemblies.Extension)')"
          />
    
  </Target>

  <UsingTask AssemblyFile="$(ls-MSBuildLibPathLocal)MSBuild.ExtensionPack.dll" TaskName="MSBuild.ExtensionPack.Compression.Zip" />
  
  <!-- This hooks up the ItemTemplate targets to the Build Process -->
  <PropertyGroup>
    <CoreCompileDependsOn Condition=" '$(ls-ItemTemplatesExtendBuild)'=='true' ">
      CopyMSBuildFilesToLocalAppData;
      $(CoreCompileDependsOn);
      ls-ProcessItemTemplates;
    </CoreCompileDependsOn>
  </PropertyGroup>  

  <PropertyGroup>
    <ls-ProcessItemTemplatesDependsOn>
      $(ls-ProcessItemTemplatesDependsOn);
      ls-DiscoverItemTemplateFiles;
      ls-AddCreatedItemTemplateZipFilesToProject;
    </ls-ProcessItemTemplatesDependsOn>
  </PropertyGroup>
  <Target Name="ls-ProcessItemTemplates" DependsOnTargets="$(ls-ProcessItemTemplatesDependsOn)" />
  
  <Target Name="ls-DiscoverItemTemplateFiles">
    <!-- Look through Item Templates folder for all .vstemplate files in the project (as Content) -->
    <ItemGroup>
      <!-- Item Templates -->
      <ls-VsTemplateFiles Include="$(ls-ItemTemplateRoot)**\*.vstemplate">
        <TemplatesRoot>$(ls-ItemTemplateRoot)</TemplatesRoot>
        <ZipRootFolder>$(ls-ItemTemplateZipRootFolder)</ZipRootFolder>
      </ls-VsTemplateFiles>

      <!-- Project Template -->
      <ls-VsTemplateFiles Include="$(ls-ProjectTemplateRoot)**\*.vstemplate">
        <TemplatesRoot>$(ls-ProjectTemplateRoot)</TemplatesRoot>
        <ZipRootFolder>$(ls-ProjectTemplateZipRootFolder)</ZipRootFolder>
      </ls-VsTemplateFiles>
    </ItemGroup>
    
    <Message Text="Vs Template Files found: @(ls-VsTemplateFiles)" />
  </Target>

  <PropertyGroup>
    <ls-CreateZipForEachItemTemplateDependsOn>
      $(ls-CreateZipForEachItemTemplateDependsOn);
      ls-DiscoverItemTemplateFiles;
      ls-InitalizeItemTemplateOutputFolder;
      ls-CalculateItemGroupOutputsForItemTemplates;
    </ls-CreateZipForEachItemTemplateDependsOn>
  </PropertyGroup>
  
  <!-- This target will run once per value in @(ls-ItemTemplatesOutputs) -->
  <Target Name="ls-CreateZipForEachItemTemplate"
          Outputs="%(_ls-ItemTemplatesOutputs.Identity)" 
          DependsOnTargets="$(ls-CreateZipForEachItemTemplateDependsOn)">

    <PropertyGroup>
      <_ls-temp-VsTemplateSourcePath></_ls-temp-VsTemplateSourcePath>
    </PropertyGroup>
    <Message Text="Determining files to incude in Item Template .zip file for [%(_ls-ItemTemplatesOutputs.VsTemplateSourcePath)]"/>

    <!-- 
    Grab all the files from the folder (excluding any .vstemplate file and any files under Definitions\)
    and create a .zip file from it in the output folder.    
    -->
    <ItemGroup>
      <_ls-ItemsToZip Remove="@(_ls-ItemsToZip)"/>
      <_ls-ItemsToZip Include="%(_ls-ItemTemplatesOutputs.ItemTemplateFolder)**\*" 
                      Exclude="%(_ls-ItemTemplatesOutputs.ItemTemplateFolder)Definitions\**\*;%(_ls-ItemTemplatesOutputs.ItemTemplateFolder)**\*.vstemplate">        
      </_ls-ItemsToZip>
    </ItemGroup>

    <Message Text="Creating Item Template .zip file at [%(_ls-ItemTemplatesOutputs.OutputPathWithFileName)]" />
    
    <!-- We need to copy the files into a subfolder under obj\ and then create the .zip file from that -->
    <PropertyGroup>
      <_ls-IntermediateItemTemplateFolder>$(ls-ItemTemplateOutputRoot)%(_ls-ItemTemplatesOutputs.ItemTemplateName)\</_ls-IntermediateItemTemplateFolder>
    </PropertyGroup>

    <!-- delete the old content and copy it over from the source -->
    <ItemGroup>
      <_ls-FilesToDelete Remove="@(_ls-FilesToDelete)"/>
      <_ls-FilesToDelete Include="$(_ls-IntermediateItemTemplateFolder)"/>
    </ItemGroup>
    <Delete Files="@(_ls-FilesToDelete)" />   
    <MakeDir Directories="$(_ls-IntermediateItemTemplateFolder)"/>
    <MakeDir Directories="" />

    <ItemGroup>
      <ls-temp-FilesCopied Remove="@(ls-temp-FilesCopied)" />
    </ItemGroup>
    <!-- Copy over the .vstemplate to the root folder and then copy all files -->
    <Copy SourceFiles="%(_ls-ItemTemplatesOutputs.VsTemplateSourcePath)"
          DestinationFiles="$(_ls-IntermediateItemTemplateFolder)%(_ls-ItemTemplatesOutputs.Filename).vstemplate">
      <Output TaskParameter ="CopiedFiles" ItemName="ls-temp-FilesCopied"/>
    </Copy>
    <Copy SourceFiles="@(_ls-ItemsToZip)"
          DestinationFiles="@(_ls-ItemsToZip->'$(_ls-IntermediateItemTemplateFolder)%(RecursiveDir)%(Filename)%(Extension)')"
          UseHardLinksIfPossible="$(ls-UseHardLinksForItemTemplatesCopy)">
      <Output TaskParameter ="CopiedFiles" ItemName="ls-temp-FilesCopied"/>
    </Copy>

    <Message Text="_ls-ItemTemplatesOutputs.Filename : [%(_ls-ItemTemplatesOutputs.Filename)]" Importance="high"/>
    <Message Text="Zipping the following files for Item Template: @(ls-temp-FilesCopied)" Importance="high"/>
    <Message Text="***: _ls-ItemTemplatesOutputs.OutputPathWithFileName:[%(_ls-ItemTemplatesOutputs.OutputPathWithFileName)]" Importance="high"/>
    <Message Text="***: _ls-IntermediateItemTemplateFolder:[$(_ls-IntermediateItemTemplateFolder)]" Importance="high" />
    <Message Text="***: _ls-ItemTemplatesOutputs.Identity:[%(_ls-ItemTemplatesOutputs.Identity)]" Importance="high" />
    <Message Text="***: _ls-ItemTemplatesOutputs.IntermediateItemTemplateFolder:[%(_ls-ItemTemplatesOutputs.IntermediateItemTemplateFolder)]" Importance="high" />
    <!-- TODO: Does the .vstemplate file need to go into the .zip file? -->
    <MSBuild.ExtensionPack.Compression.Zip
      TaskAction="Create"
      CompressFiles="@(ls-temp-FilesCopied)"
      ZipFileName="%(_ls-ItemTemplatesOutputs.Identity)"
      RemoveRoot="$(_ls-IntermediateItemTemplateFolder)"
      CompressionLevel="BestCompression" />
    
    <ItemGroup>
      <ls-ItemTempZipIntermediateFiles Include="%(_ls-ItemTemplatesOutputs.Identity)"/>
    </ItemGroup>
    
  </Target>

  <Target Name="ls-InitalizeItemTemplateOutputFolder">
    <MakeDir Directories="$(ls-ItemTemplateOutputRoot)"/>
  </Target>

  <PropertyGroup>
    <ls-CalculateItemGroupOutputsForItemTemplates>
      $(ls-CalculateItemGroupOutputsForItemTemplates);
      ls-DiscoverItemTemplateFiles
    </ls-CalculateItemGroupOutputsForItemTemplates>
  </PropertyGroup>
  <!-- This target will run once per value in @(ls-ItemTemplateOutputRoot) -->
  <Target Name="ls-CalculateItemGroupOutputsForItemTemplates" 
          Inputs="%(ls-VsTemplateFiles.Identity)"
          Outputs="%(ls-VsTemplateFiles.Identity);All"
          DependsOnTargets="$(ls-CalculateItemGroupOutputsForItemTemplates)">

    <Message Text="ls-CalculateItemGroupOutputsForItemTemplates. ls-VsTemplateFiles:[ @(ls-VsTemplateFiles)]" />
    <!-- By the time this target is called the item ls-DiscoverItemTemplateFiles should be fully populated. 
    No additions after this point -->

    <PropertyGroup>
      <_TemplatesRoot>%(ls-VsTemplateFiles.TemplatesRoot)</_TemplatesRoot>
      <_ZipRootFolder>%(ls-VsTemplateFiles.ZipRootFolder)</_ZipRootFolder>
    </PropertyGroup>

    <Message Text="_TemplatesRoot:[$(_TemplatesRoot)]" Importance="high"/>
    <Message Text="_ZipRootFolder:[$(_ZipRootFolder)]" Importance="high"/>
    
    <!-- ls-ItemTemplateOutputRoot -->
    <GetItemTemplateNameFromVSTemplatePath 
      VstemplateFilePath="@(ls-VsTemplateFiles)"
      ItemTemplateRoot="$(_TemplatesRoot)"
      ItemTemplateZipRootFolder="$(_ZipRootFolder)"
      CustomTemplatesFolder="$(ls-TemplateSubFolder)">
      <Output TaskParameter="ItemTemplateName" PropertyName="_ls-ItemTemplateName" />
      <Output TaskParameter="ItemTemplateFolder" PropertyName="_ls-ItemTemplateFolder" />
      <Output TaskParameter="OutputPathWithFileName" PropertyName="OutputPathWithFileName" />
      <Output TaskParameter="OutputPathFolder" PropertyName="OutputPathFolder"/>
    </GetItemTemplateNameFromVSTemplatePath>
    
    <ItemGroup>
      <_ls-ItemTemplatesOutputs Include="@(ls-VsTemplateFiles->'$(ls-ItemTemplateOutputRoot)$(_ls-ItemTemplateName).zip')">
        <ItemTemplateName>$(_ls-ItemTemplateName)</ItemTemplateName>
        <VsTemplateSourcePath>%(ls-VsTemplateFiles.Identity)</VsTemplateSourcePath>
        <ItemTemplateFolder>$(_ls-ItemTemplateFolder)</ItemTemplateFolder>

        <OutputPathWithFileName>$(OutputPathWithFileName)</OutputPathWithFileName>
        <OutputPathFolder>$(OutputPathFolder)</OutputPathFolder>
      </_ls-ItemTemplatesOutputs>
    </ItemGroup>

    <Message Text="_ls-ItemTemplatesOutputs.ItemTemplateName: [%(_ls-ItemTemplatesOutputs.ItemTemplateName)]" Importance="high" />
    <Message Text="_ls-ItemTemplatesOutputs.Identity: [%(_ls-ItemTemplatesOutputs.Identity)]" Importance="high" />
    <Message Text="ls-ItemTemplateZipRootFolder: $(ls-ItemTemplateZipRootFolder)" Importance="high" />
    <Message Text="OutputPathWithFileName:$(OutputPathWithFileName)" Importance="high"/>
    <Message Text="%(_ls-ItemTemplatesOutputs.OutputPathWithFileName)" Importance="high"/>
    <!--<Error Text="************ stopping build *********************" />-->
    <Message Text="_ls-ItemTemplatesOutputs.VsTemplateSourcePath: %(_ls-ItemTemplatesOutputs.VsTemplateSourcePath)" />
  </Target>

  <PropertyGroup>
    <ls-AddCreatedItemTemplateZipFilesToProjectDependsOn>
      $(ls-AddCreatedItemTemplateZipFilesToProjectDependsOn);
      ls-CreateZipForEachItemTemplate;
    </ls-AddCreatedItemTemplateZipFilesToProjectDependsOn>
  </PropertyGroup>
  
  <Target Name="ls-AddCreatedItemTemplateZipFilesToProject" DependsOnTargets="$(ls-AddCreatedItemTemplateZipFilesToProjectDependsOn)" >
    <Message Text="Adding the following files to Content: [@(ls-ItemTempZipIntermediateFiles)]" />
    
    <!-- TODO: add this to VSIXSourceItem-->
    <!-- Add the produced .zip files to Content so that they are included in the package -->
    <ItemGroup>
      <VSIXSourceItem Include="%(_ls-ItemTemplatesOutputs.Identity)">
        <VSIXSubPath>%(_ls-ItemTemplatesOutputs.OutputPathFolder)</VSIXSubPath>
      </VSIXSourceItem>

    </ItemGroup>

    <Message Text="VSIXSubPath: [%(ls-ItemTempZipIntermediateFiles.OutputPathFolder)]" Importance="high"/>    
  </Target>

  <!--************************************************************************************
      Inline Tasks defined below
  ************************************************************************************-->
  <UsingTask TaskName="GetItemTemplateNameFromVSTemplatePath" TaskFactory="CodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.v4.0.dll">
    <ParameterGroup>
      <VstemplateFilePath ParameterType="System.String" Required="true"/>
      <ItemTemplateRoot ParameterType="System.String" Required="true"/>
      <!-- If provided this value should end in a '\' -->
      <ItemTemplateZipRootFolder ParameterType="System.String" Required="false"/>
      <CustomTemplatesFolder ParameterType="System.String" Required="false" />
      
      <!-- Outputs -->
      <ItemTemplateName ParameterType="System.String" Output="true"/>
      <ItemTemplateFolder ParameterType="System.String" Output="true"/>
      <ZipfileName ParameterType="System.String" Output="true"/>
      <OutputPathFolder ParameterType="System.String" Output="true"/>
      <OutputPathWithFileName ParameterType="System.String" Output="true" />
    </ParameterGroup>
    <Task>
      <Reference Include="System.Core" />
      <Using Namespace="System" />
      <Using Namespace="System.IO" />
      <Using Namespace="System.Net" />
      <Using Namespace="Microsoft.Build.Framework" />
      <Using Namespace="Microsoft.Build.Utilities" />
      <Code Type="Fragment" Language="cs">
        <!-- TODO: Make the folder name 'SideWaffle' into a parameter -->
        <![CDATA[
                Log.LogMessage("GetItemTemplateNameFromVSTemplatePath Starting");
                System.IO.FileInfo fi = new System.IO.FileInfo(VstemplateFilePath);
                System.IO.DirectoryInfo di = fi.Directory;

                var ItemTemplateFolderInfo = new System.IO.FileInfo(di.Parent.FullName);
                ItemTemplateFolder = ItemTemplateFolderInfo.FullName + @"\";

                // we need to get the name of the first folder under 'ItemTemplates' (ItemTemplateRoot)
                var itemTemplateRootUri = new Uri(ItemTemplateRoot);
                var relFolder = itemTemplateRootUri.MakeRelativeUri(new Uri(VstemplateFilePath)).ToString();
                var templateRelPath = relFolder.Substring(0, relFolder.IndexOf('/'));

                if (ItemTemplateZipRootFolder == null) {
                    ItemTemplateZipRootFolder = string.Empty;
                }

                string itRootFileName = di.Parent.Name;
                string subFolder = this.CustomTemplatesFolder;

                ZipfileName = string.Format(
                  "{0}{1}.zip",
                  ItemTemplateName,
                  fi.Name);
                // set OutputFolder
                // if the name is 
                //  'CSharp.vstemplate' -> CSharp\
                //  'Web.CSharp.vstemplate' -> CSharp\Web\
                //  'VB.vstemplate' -> VisualBasic\
                //  'Web.VB.vstemplate' -> VisualBasic\Web\
                if (string.Compare(@"CSharp.vstemplate", fi.Name, StringComparison.OrdinalIgnoreCase) == 0) {
                    ItemTemplateName = string.Format("{0}.csharp", itRootFileName);
                    OutputPathFolder = string.Format(@"{0}CSharp\{1}\{2}", ItemTemplateZipRootFolder, templateRelPath, subFolder);
                }
                else if (string.Compare(@"Web.CSharp.vstemplate", fi.Name, StringComparison.OrdinalIgnoreCase) == 0) {
                    ItemTemplateName = string.Format("{0}.web.csharp", itRootFileName);

                    // web site templates do not support any nesting
                    OutputPathFolder = string.Format(@"{0}CSharp\Web\{1}", ItemTemplateZipRootFolder, subFolder);
                }
                else if (string.Compare(@"VB.vstemplate", fi.Name, StringComparison.OrdinalIgnoreCase) == 0) {
                    ItemTemplateName = string.Format("{0}.VB", itRootFileName);
                    OutputPathFolder = string.Format(@"{0}VisualBasic\{1}\{2}", ItemTemplateZipRootFolder, templateRelPath, subFolder);
                }
                else if (string.Compare(@"Web.VB.vstemplate", fi.Name, StringComparison.OrdinalIgnoreCase) == 0) {
                    ItemTemplateName = string.Format("{0}.web.VB", itRootFileName);

                    // web site templates do not support any nesting
                    OutputPathFolder = string.Format(@"{0}VisualBasic\Web\{1}", ItemTemplateZipRootFolder, subFolder);
                }
                else {
                    Log.LogError("Unknown value for ItemTemplateName: [{0}]. Supported values include 'CSharp.vstemplate','Web.CSharp.vstemplate','VB.vstemplate' and 'Web.VB.vstemplate' ", fi.Name);
                    return false;
                }

                OutputPathWithFileName = string.Format(@"{0}{1}", OutputPathFolder, itRootFileName);   
            ]]>
      </Code>
    </Task>
  </UsingTask>
</Project>